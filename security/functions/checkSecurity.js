"use strict";

//
// Boilerplate code generated by the transpiler,
//    the actual code is below.
const { option } = require("yargs");

function e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function t(e, t, o) {
  return e(o = {
    path: t, exports: {
    }
    , require(e, t) {
      return function () {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
      }
        (null == t && o.path)
    }
  }
    , o.exports), o.exports
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

const o = t((function (e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }
  ), t.isObject = void 0, t.isObject = function (e) {
    return null !== e && "object" == typeof e
  }
}));

//
// The actual code.
//
const n = t((function (e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }
  ), t.getAllOperations = void 0;
  const n = ["get", "head", "post", "put", "patch", "delete", "options", "trace"];
  t.getAllOperations = function* (e) {
    if (!o.isObject(e)) {
      return;
    }
    const t = { path: "", operation: "" } ;
    for (const r of Object.keys(e)) {
      const s = e[r];
      if (o.isObject(s)) {
        t.path = r;
        for (const e of Object.keys(s)) {
          o.isObject(s[e]) && n.includes(e) && (t.operation = e, yield t)
        }
      }
    }
  }
}
));
function myget(value, path) {  // _get
      // console.log("_get", value, path)
      for (const segment of path) {
        if (!o.isObject(value)) {
          break;
        }
        value = value[segment]
      }
      return value
    }
//
// The exported function.
//
const checkSecurity = e(t((function (e, t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), 
  t.oasOpSecurityDefined = void 0, t.oasOpSecurityDefined = (input, options) => {
    // console.log("input", input);
    // console.log("options", options);
    const r = [];
    const { schemesPath: s, nullable: nullable, methods: methods } = options;
    const { paths: i } = input;
    const c = myget(input, s);
    const u = o.isObject(c) ? Object.keys(c) : [];
    // console.log("myget", c, u)

    for (const { path: e, operation: t } of n.getAllOperations(i)) {
      if (methods && Array.isArray(methods) && !methods.includes(t)) {
        // console.debug("Skipping method", t)
        continue;
      }
      // console.log("operation", e, t)
      let { security: n } = i[e][t];
      let securityRef = [e, t]
      if (n === undefined) {
        n = input.security
        securityRef = ["$.security"]
      };
      // console.log("security", n)
      if (!n) {
        r.push({
            message: `Operation has undefined security scheme in ${securityRef}.`,
            path: ["paths", e, t, "security", s]
          })
      }

      if (Array.isArray(n)) {
        for (const [s, i] of n.entries()) {
          if (!o.isObject(i)) {
            continue;
          }
          const n = Object.keys(i);
          n.length === 0 && (nullable === false) && r.push({
            message: `Operation referencing empty security scheme in ${securityRef}.`,
            path: ["paths", e, t, "security", s]
          }
          )
        }
      }
    }
    return r
  }, t.default = t.oasOpSecurityDefined
}
)));
exports.default = checkSecurity;

